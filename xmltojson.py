# -*- coding: utf-8 -*-
"""XMLtoJson

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1I-5TUlU6SSvSIdtZFq3vq0L5FN8PYGG2

-------------------------------------

-------------------------------------

<div class="alert alert-block alert-warning">
    
## 2.  Importing Libraries  <a class="anchor" name="libs"></a>
 </div>

In our code, integrating `re`, `pandas`, and `json` libraries boosts functionality. `re` enhances text processing with regex. `pandas` empowers efficient data handling, from loading to visualization. `json` facilitates seamless interaction with JSON data, crucial for web APIs and file I/O. Overall, these enrichments optimize code efficiency.
"""

import re
import pandas as pd
import json

"""Integrating Google Drive with Colab, we enable seamless file access. Mounting Drive provides direct access to files stored in Drive. By specifying the file path, we facilitate operations on specific files within the Drive, such as reading, writing, and processing data."""

from google.colab import drive
# drive.flush_and_unmount()
drive.mount('/content/drive')
# file_path = r'/content/drive/DATA WRANGLING/Group037.txt'

"""-------------------------------------

<div class="alert alert-block alert-warning">

## 3.  Examining Raw Data <a class="anchor" name="examine"></a>

 </div>

First of all, ....

Having examined the file content, the following observations were made:
"""

# It has been noted that the .txt document comprises a dataset pertinent to a real estate agency or property sales firm. The content resembles internal office records featuring reel
#  and frame numbers for unique file identification. Subsequently, there's a last updated date, albeit in an incorrect format. Following that, there's conveyance text detailing the
#   involved parties, including the assignor and assignee of the property, along with their respective details. Additionally, it lists the properties implicated in the transaction.

"""-------------------------------------

<div class="alert alert-block alert-warning">

## 4.  Loading and Parsing Files <a class="anchor" name="load"></a>

</div>

Incorporating file handling in our code, we access and read data from the specified text file stored in Google Drive. After reading the file contents, we split the text into lines for further processing. This facilitates data parsing and manipulation for subsequent tasks.
"""

with open('/content/drive/Shared drives/FIT5196_S1_2024/A1/Students data/Task 1/Group037.txt', 'r') as file:
    # Read the contents of the file
    text_data = file.read()
    # print(text_data[:10])
    lines = text_data.split('\n')
    # for line in lines[:10]:
    #   print(lines)

"""-------------------------------------

<div class="alert alert-block alert-info">
    
### 4.1. Defining Regular Expressions <a class="anchor" name="Reg_Exp"></a>

Our code incorporates various regular expression patterns tailored to extract specific information from structured text data. These patterns target elements such as reel and frame numbers, dates, conveyance details, correspondent names, assignor and assignee information, and property-related data. These patterns enable us to parse and capture relevant details, facilitating subsequent analysis and processing of the text data.
"""

reel_pattern = r'<reel-no>(\d+)<\/reel-no>'
frame_pattern = r'<frame-no>(\d+)<\/frame-no>'
pattern_id = r"<(?:reel|frame)-no>(\d+)<\/(?:reel|frame)-no>"
date_pattern = r'<last-update-date>(\d{4})(\d{2})(\d{2})<\/last-update-date>'
conveyance_pattern = r'<conveyance-text>(.*?)<\/conveyance-text>'
correspondent_pattern = r'<correspondent>\s*<person-or-organization-name>(.*?)<\/person-or-organization-name>'
assignor_pattern = r'<assignor>.*?<person-or-organization-name>(.*?)<\/person-or-organization-name>.*?<execution-date>(.*?)<\/execution-date>.*?<legal-entity-text>(.*?)<\/legal-entity-text>.*?<nationality>(.*?)<\/nationality>.*?<\/assignor>'
# assignor_pattern = r'<assignors>.*?<assignor>.*?<person-or-organization-name>(.*?)<\/person-or-organization-name>.*?<execution-date>(.*?)<\/execution-date>.*?<legal-entity-text>(.*?)<\/legal-entity-text>.*?<nationality>(.*?)<\/nationality>.*?<\/assignor>.*?<\/assignors>'
assignee_pattern = r'<assignees>.*?<assignee>.*?<person-or-organization-name>(.*?)<\/person-or-organization-name>.*?.*?<legal-entity-text>(.*?)<\/legal-entity-text>.*?<\/assignee>.*?<\/assignees>'
property_pattern = r'<properties>(.*?)<\/properties>'

"""These patterns are used in the next step when reading the files.

-------------------------------------

<div class="alert alert-block alert-info">
    
### 4.2. Reading Files <a class="anchor" name="Read"></a>

In this step, all files are read and parsed. The code employs regular expressions to extract diverse data from structured text. It captures RF IDs by concatenating reel and frame numbers, dates in YYYY-MM-DD format, conveyance text, correspondent details, assignor and assignee information, and property counts. These extractions facilitate comprehensive data analysis and processing.

RF IDs Extraction:
The code utilizes regular expressions to find matches for a pattern representing reel and frame numbers.
It iterates over the matches, concatenating the reel and frame numbers to form RF IDs.
These RF IDs are stored in a list for further analysis or processing.
Dates Extraction:
Regular expressions are employed to locate matches for a pattern representing dates in the text data.
Each date match is formatted into the YYYY-MM-DD date format for consistency and ease of interpretation.
The formatted dates are collected in a list for subsequent analysis or usage.
Conveyance Text Extraction:
The code searches for matches using a regular expression pattern designed to capture text within <conveyance-text> tags.
If matches are found, the corresponding text is appended to a list; otherwise, "NA" is appended to indicate no data found.
The list of conveyance texts is prepared for further examination or processing.
Correspondent Text Extraction:
Regular expressions are employed to identify matches for a pattern representing correspondent details.
Each match captures the content within <person-or-organization-name> tags under <correspondent> tags.
The captured text is stored in a list for subsequent analysis or usage.
Assignor Information Extraction:
The code utilizes regular expressions to find matches for a pattern representing assignor information.
Assignor details such as party name, execution date, and legal entity text are extracted from each match.
Extracted information is organized into dictionaries and stored in a list for further analysis or processing.
Assignee Information Extraction:
Similar to assignor information extraction, regular expressions are employed to locate matches for a pattern representing assignee details.
Assignee information, including party name and legal entity text, is extracted from each match.
Extracted details are structured into dictionaries and appended to a list for subsequent analysis or usage.
Property Count Extraction:
The code searches for matches using a regular expression pattern designed to capture text within <properties> tags.
For each match, the count of <property> tags is determined to assess the number of properties associated with the text data.
The counts are collected in a list to provide insight into the distribution or frequency of properties.
These detailed sections illustrate how the code employs regular expressions to extract specific information from structured text data, facilitating comprehensive analysis and interpretation of the data's contents.
"""

rf_ids = []

# Find all matches using re.findall()
match_id = re.findall(pattern_id, text_data)
# Iterate over matches and concatenate reel and frame numbers
for i in range(0, len(match_id), 2):
    reel_number = match_id[i]
    frame_number = match_id[i+1]
    combined_number = reel_number + frame_number
    rf_ids.append(combined_number)

# Print the combined reel and frame numbers
print(len(rf_ids))
print("rfids are :")
# for number in rf_ids[:10]:
#     print(number)


''' Dates'''

#  Find all matches using re.findall()
date_matches = re.findall(date_pattern, text_data)

# Iterate over matches and format the dates
dates = []
for match in date_matches:
    year, month, day = match
    formatted_date = f"{year}-{month}-{day}"
    dates.append(formatted_date)

# print("first 10 updadated dates are")
# for date in dates[:10]:
#     print(date)

print(len(dates))
'''Conveyence text'''

# Find all matches using re.findall()
con_matches = re.findall(conveyance_pattern, text_data)

# List to store all results
c_results = []

if not con_matches:
  c_results.append["NA"]
else:
  # Iterate over matches and append the content or "NA" if nothing is found
  for match in con_matches:
      if match:
          c_results.append(match)
      else:
          c_results.append("NA")

# Print the list of results
print(len(c_results))
# print("Conveyence texts are")
# for i in c_results[:10]:
#   print(i)

'''Correspondent text'''

#Find all matches
correspondent_matches = re.findall(correspondent_pattern, text_data)

#List to store correspondent
corr_results = []

#itirate over matches and store them in a list
for match in correspondent_matches:
  if match:
    corr_results.append(match)
  else:
    corr_results.append("NA")
print(len(corr_results))

for i in corr_results[:10]:
  print(i)

''' Assignor Info'''

assignors_info = []

assignor_matches = re.findall(assignor_pattern, text_data, re.DOTALL)

for match in assignor_matches:
    party_name = match[1].split(',')[0].strip()  # Remove title if present
    execution_date = match[2] if match[2] else "NA"
    legal_entity_text = match[3] if match[3] else 'NA'

    assignors_info.append({
        "party-name": party_name,
        # "date-acknowledged": "",  # This field is not present in the regex pattern
        "execution-date": execution_date,
        # "country": country,
        "legal-entity-text": legal_entity_text
    })
# for i in assignors_info[:10]:
#   print(i)
print("Assignor Info")
print(len(assignors_info))

''' Assignee Info'''

assignees_info = []

assignee_matches = re.findall(assignee_pattern, text_data, re.DOTALL)
print("this")
# print(assignee_matches)

for match in assignee_matches:
    party_name = match[0].split(',')[0].strip()  # Remove title if present
    legal_entity_text = match[1]
    assignees_info.append({
      "party-name": party_name,
      # "country": country,
      "legal-entity-text": legal_entity_text
      })



# for i in assignees_info[:10]:
#   print(i)

print(len(assignees_info))



''' Property count'''



#Property
property_matches = re.findall(property_pattern, text_data, re.DOTALL)
# print(property_matches)
properties_counts = []
for match in property_matches:
    count = match.count('<property>')
    properties_counts.append(count)
print(properties_counts)

"""-------------------------------------

<div class="alert alert-block alert-info">
    
### 4.3. Whatever else <a class="anchor" name="latin"></a>

Code Overview:

Regular Expression Compilation:
Regular expressions are compiled for efficient pattern matching.
re.compile() is used along with the re.DOTALL flag for comprehensive matching.
Data Structures Initialization:
Dictionaries (data, assignor_data, assignee_data) are initialized to store extracted information.
A utility function replace_missing() handles missing values, replacing them with "NA".
Assignment Entry Extraction:
All assignment entries are extracted using assignment_entry_pattern.findall().
Assignment data is then extracted from each entry using assignment_pattern.search().
RF IDs Extraction:
RF IDs are formed by concatenating reel and frame numbers extracted using pattern_id.findall().
Dates Extraction:
Dates are extracted using date_pattern.findall() and formatted as YYYY-MM-DD.
Missing dates are replaced with "NA" using replace_missing().
Conveyance Text Extraction:
Conveyance text is extracted using conveyance_pattern.search().
Missing conveyance text is replaced with "NA" using replace_missing().
Correspondent Text Extraction:
Correspondent party names are extracted using correspondent_pattern.search().
Missing names are replaced with "NA" using replace_missing().
Assignor Information Extraction:
Assignor details are extracted using assignor_pattern.search() and processed.
Extracted data is stored in the assignor_data dictionary.
Assignee Information Extraction:
Assignee details are extracted using assignee_pattern.search() and processed.
Extracted data is stored in the assignee_data dictionary.
Property Count Extraction:
Property counts are determined by counting <property> occurrences using property_pattern.findall().
Nested JSON Creation:
Extracted data is structured into nested JSON format.
Each RF ID serves as a key, with corresponding information nested under it.
Writing JSON to File:
JSON data is written to a file using json.dump() with indentation for readability.
File Writing and Data Clearing:
JSON data is appended to the file, and data dictionaries are cleared for the next iteration.
"""

reel_pattern = re.compile(r'<reel-no>(\d+)<\/reel-no>')
frame_pattern = re.compile(r'<frame-no>(\d+)<\/frame-no>')
pattern_id = re.compile(r"<(?:reel|frame)-no>(\d+)<\/(?:reel|frame)-no>")
date_pattern = re.compile(r'<last-update-date>(\d{4})(\d{2})(\d{2})<\/last-update-date>')
conveyance_pattern = re.compile(r'<conveyance-text>(.*?)<\/conveyance-text>')
correspondent = re.compile(r'<correspondent>\s*<person-or-organization-name>(.*?)<\/person-or-organization-name>')
# correspondent_pattern = re.compile(r'<correspondent>\s*<person-or-organization-name>(.*?)<\/person-or-organization-name>')
assignor_pattern = re.compile(r'<assignor>([\s\S]*?)<\/assignor>')
# assignor_pattern = r'<assignors>.*?<assignor>.*?<person-or-organization-name>(.*?)<\/person-or-organization-name>.*?<execution-date>(.*?)<\/execution-date>.*?<legal-entity-text>(.*?)<\/legal-entity-text>.*?<nationality>(.*?)<\/nationality>.*?<\/assignor>.*?<\/assignors>'
assignees_pattern = re.compile(r'<assignees>([\s\S]*?)<\/assignees>')
assignee_pattern = re.compile(r'<assignee>([\s\S]*?)<\/assignee>')
property_pattern = re.compile(r'<properties>(.*?)<\/properties>')
assignment_entry_pattern = re.compile(r'<assignment-entry>(.*?)</assignment-entry>', re.DOTALL)
assignment_pattern = re.compile(r'<assignment>(.*?)<\/assignment>', re.DOTALL)
person_name_pattern = re.compile(r'<person-or-organization-name>(.*?)<\/person-or-organization-name>', re.DOTALL)
date_acknowledged_pattern = re.compile(r'<date-acknowledged>(\d{4})(\d{2})(\d{2})<\/date-acknowledged>', re.DOTALL)
execution_date_pattern = re.compile(r'<execution-date>(\d{4})(\d{2})(\d{2})<\/execution-date>', re.DOTALL)
country_pattern = re.compile(r'<nationality>(.*?)<\/nationality>', re.DOTALL)
assignee_person_name_pattern = re.compile(r'<person-or-organization-name>(.*?)<\/person-or-organization-name>', re.DOTALL)
nationality_pattern = re.compile(r'<nationality>(.*?)<\/nationality>', re.DOTALL)
legal_entity_text_pattern = re.compile(r'<legal-entity-text>(.*?)<\/legal-entity-text>', re.DOTALL)
property_pattern = r"<property>[\s\S]*?</property>"




# Function to handle missing values
def replace_missing(value):
    return value if value else 'NA'



data = {
    'rf-id': [],
    'last-update-date': [],
    'conveyance-text': [],
    'correspondent-party': [],
    'assignor-info': {},
    'assignee-info': {},
    'Property-count':[]

}

assignor_data = {
        'party-name': [],
        'date_acknowledged': [],
        'execution_date': [],
        'country': [],
        'legal-entity-text': []
}

assignee_data = {
      'party-name': [],
      'country': [],
      'legal_entity_text': []
  }

#Searching for all assignements entry data
assignment_entries = assignment_entry_pattern.findall(text_data)
# for i in assignment_entries[:2]:
#   print(i)

# Iterate over assignment entries
# print(type(assignment_entries))
for i, entry in enumerate(assignment_entries, start=0):
    # print(type(entry))
    # print(f"lol",i)
    # print(entry)
    # print(type(entry))
    # Extract assignment data
    assignment_match = re.search(assignment_pattern, entry)
    # print(assignment_match if assignment_match else None)
    if assignment_match:
        assignment = assignment_match.group(1) # Searchs the assignement within assignments
        # print(assignment)
        correspondent = re.search(correspondent_pattern, assignment, re.DOTALL) # Searchs the correspondent-party within assignments
        match_id = re.findall(pattern_id, assignment) # Searchs the matched id within assignments
        reel_no_match = re.search(reel_pattern, assignment)
        frame_no_match = re.search(frame_pattern, assignment)

        if reel_no_match and frame_no_match:
          reel_number = reel_no_match.group(1)
          frame_number = frame_no_match.group(1)
          combined_number = reel_number + frame_number # Searchs the frame_id within assignments
        # print(frame_no)
        date_matches = re.findall(date_pattern, entry) # Searchs the last-update-date within assignments




        conveyance_text = re.search(conveyance_pattern, assignment) # Searchs the conveyence-text within assignments

        # reel_number = match_id[i]
        # print(match_id[i])
        # frame_number = match_id[i+1]
        # print(match_id[i+1])
        # combined_number = reel_number + frame_number #rf-id
        data['rf-id'].append(combined_number)
        # print(date_matches)

        for match in date_matches:
          year, month, day = match
          formatted_date = f"{year}-{month}-{day}"
          break
        data['last-update-date'].append(replace_missing(formatted_date if match else None))

        if conveyance_text:
          data['conveyance-text'].append(replace_missing(conveyance_text.group(1) if conveyance_text else None))
        else:
           data['conveyance-text'].append("NA")

        data['correspondent-party'].append(replace_missing(correspondent.group(1) if correspondent else None))





    # Searchs the assignors within assignments
    assignor_match = re.search(assignor_pattern, entry)
    # print(entry[0])
    # print(assignor_match)
    if assignor_match:
        # print(assignor_match.group(1))
        person_names = re.findall(person_name_pattern, assignor_match.group(1)) #searches a assignor within assignors
        # print(person_names)

        date_acknowledged = re.findall(date_acknowledged_pattern, assignor_match.group(1)) #searches acknoledged date within assignors
        # print(date_acknowledged)

        execution_date = re.findall(execution_date_pattern, assignor_match.group(1)) #searches execution date within assignors
        countries = re.findall(country_pattern, assignor_match.group(1))
        legal_entity_texts = re.findall(legal_entity_text_pattern, assignor_match.group(1))
        # print(legal_entity_text)
        # Append extracted data to lists
        for person_name_match in person_names:
           assignor_data['party-name'].append(replace_missing(person_name_match if person_name_match else None ))
        # for date_acknowledged_match in date_acknowledged:
        # print(date_acknowledged)
        if date_acknowledged:
          for match in date_acknowledged:
          # print(match)
            year, month, day = match
            formatted_date = f"{year}-{month}-{day}"
            # print(formatted_date)
          # break
          # print(formatted_date)
          assignor_data['date_acknowledged'].append(formatted_date)
        else:
          assignor_data['date_acknowledged'].append("NA")

        # print(execution_date)
        for match in execution_date:
          year, month, day = match
          formatted_date = f"{year}-{month}-{day}"
          break
        assignor_data['execution_date'].append(replace_missing(formatted_date))
        if countries:
          for country_match in countries:
              assignor_data['country'].append(replace_missing(country_match))
        else:
          assignor_data['country'].append("NA")
        for legal_entity_text_match in legal_entity_texts:
            # print(legal_entity_text_match)
            assignor_data['legal-entity-text'].append(replace_missing(legal_entity_text_match if legal_entity_text_match else None))
        data['assignor-info'] = assignor_data






  # Extract assignee data

    assignees_match = re.search(assignees_pattern, entry)
    # print(assignees_match)
    if assignees_match:
      assignee_match = re.search(assignee_pattern, entry)
      # print(assignee_match)
      # print(assignee_match)
      if assignee_match:
        names = re.findall(person_name_pattern, assignee_match.group(1))
        nationalities = re.findall(nationality_pattern, assignee_match.group(1))
        legal_entity_texts = re.findall(legal_entity_text_pattern, assignee_match.group(1))
        # Append extracted data to lists
        # Iterate over the list of matches for names
        for name_match in names:
            assignee_data['party-name'].append(replace_missing(name_match if name_match else None))

        # Iterate over the list of matches for nationalities
        if nationalities:
          for nationality_match in nationalities:
              assignee_data['country'].append(replace_missing(nationality_match if nationality_match else None))
        else:
          assignee_data['country'].append(replace_missing("NA"))
        # Iterate over the list of matches for legal_entity_texts
        if legal_entity_texts:
          for legal_entity_text_match in legal_entity_texts:
              assignee_data['legal_entity_text'].append(replace_missing(legal_entity_text_match if legal_entity_text_match else None))
        else:
          assignee_data['legal_entity_text'].append(replace_missing("NA"))
        data['assignee-info'] = assignee_data

    properties = re.findall(property_pattern, entry)
    property_count = len(properties)
    data['Property-count'].append(property_count)
    for key, value_list in data.items():
          print(f"{key}: {value_list}")
    print("")
   # Convert data to nested JSON structure
    nested_json = {}
    for i in range(len(data['rf-id'])):
      rf_id = data['rf-id'][i]
      entry = {
          'last-update-date': data['last-update-date'][i],
          'conveyance-text': data['conveyance-text'][i],
          'correspondent-party': data['correspondent-party'][i],
          'assignors-info': [{
              'party-name': data['assignor-info']['party-name'][i],
              'date-acknowledged': data['assignor-info']['date_acknowledged'][i],
              'execution-date': data['assignor-info']['execution_date'][i],
              'country': data['assignor-info']['country'][i],
              'legal-entity-text': data['assignor-info']['legal-entity-text'][i]
          }],
          'assignees-info': [{
              'party-name': data['assignee-info']['party-name'][i],
              'country': data['assignee-info']['country'][i],
              'legal-entity-text': data['assignee-info']['legal_entity_text'][i]
          }],
          'property-count': data['Property-count'][i]
      }
    nested_json[rf_id] = entry

# Convert nested JSON to JSON string
    json_string = json.dumps(nested_json, indent=4)
    print(json_string)

    with open('/content/drive/My Drive/task1_037.json', 'a', encoding='utf-8') as file:
        file.write(json_string + '\n')

    #clear all dictionaries
    data = {
    'rf-id': [],
    'last-update-date': [],
    'conveyance-text': [],
    'correspondent-party': [],
    'assignor-info': {},
    'assignee-info': {},
    'Property-count':[]

    }

    assignor_data = {
            'party-name': [],
            'date_acknowledged': [],
            'execution_date': [],
            'country': [],
            'legal-entity-text': []
    }

    assignee_data = {
          'party-name': [],
          'country': [],
          'legal_entity_text': []
      }















# for key, value_list in data.items():
#           print(f"{key}: {value_list}")

"""It's important to highlight a particular approach used here: rather than storing all data in a single dictionary, I've initialized a dictionary, converted it into JSON format, cleared it, and then repeated this process for each assignment entry.

-------------------------------------

<div class="alert alert-block alert-warning">

## 5.  Writing to XML File <a class="anchor" name="write"></a>

</div>
"""



"""....

-------------------------------------

<div class="alert alert-block alert-info">
    
### 5.1. Verification of the Generated XML File <a class="anchor" name="test_xml"></a>

....
"""



"""-------------------------------------

<div class="alert alert-block alert-warning">

## 6. Summary <a class="anchor" name="summary"></a>

</div>

The code utilizes regular expressions to extract structured data from text entries efficiently. It compiles regex patterns for matching various data elements and initializes dictionaries to store the extracted information. For each assignment entry, it systematically extracts relevant details, including RF IDs, dates, conveyance text, correspondent information, assignor and assignee data, and property counts. This information is meticulously organized into a nested JSON format, facilitating easy access and analysis. Each JSON object represents a unique assignment entry, encapsulating all pertinent details within its structure. Finally, the extracted data is written to a file, ensuring persistence and enabling further processing or analysis. This systematic approach ensures accurate extraction and organization of data from complex text sources, streamlining subsequent tasks such as data analysis or integration into other systems.

-------------------------------------

<div class="alert alert-block alert-warning">

## 7. References <a class="anchor" name="Ref"></a>

</div>

re.dotall

GeeksforGeeks. (2020, October 1). Python Flags to Tune the Behavior of Regular Expressions. Retrieved from https://www.geeksforgeeks.org/python-flags-to-tune-the-behavior-of-regular-expressions/

re.compile

PyNative. (2021, April 2). Python Compile Regex Pattern using re.compile(). Retrieved from https://pynative.com/python-regex-compile/

## --------------------------------------------------------------------------------------------------------------------------
"""